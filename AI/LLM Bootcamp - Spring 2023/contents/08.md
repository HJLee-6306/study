
### **[8주차] 스스로 생각하고 행동하는 LLM: 고급 에이전트(Agents)**

**부제: LLM에게 도구를 쥐여주는 법**

---

### **1. 강의 개요 (Lecture Overview)**

#### **학습 목표 (Learning Objectives)**

이번 주, 우리는 LLM을 단순한 '답변 생성기'에서 '문제 해결사'로 진화시키는 방법을 배웁니다.

1.  **에이전트 개념 이해:** LLM을 **추론 엔진(Reasoning Engine)**으로 사용하여, 정해진 순서 없이 스스로 목표를 달성하기 위한 행동 계획을 수립하고 실행하는 '에이전트'의 개념을 이해합니다.
2.  **핵심 프레임워크 학습:** 에이전트를 구현하는 가장 대표적인 프레임워크인 **ReAct(Reason + Act)**의 작동 원리를 심층적으로 파악합니다.
3.  **Tool-Use 마스터:** LLM이 최신 정보를 검색하고, 복잡한 계산을 수행하며, 외부 시스템과 상호작용할 수 있도록 **'도구(Tool)'**를 연결하고 사용하는 방법을 배웁니다.
4.  **에이전트의 한계와 도전과제 인식:** 에이전트가 왜 아직 프로덕션 환경에서 사용하기 어려운지, 신뢰성을 높이기 위해 어떤 문제들을 해결해야 하는지 현실적인 관점을 갖춥니다.

#### **지난주 복습 및 이번 주의 질문 (Review & Question of the Week)**

지난주까지 우리는 RAG를 통해 LLM에게 '읽는' 능력을, LLMOps를 통해 시스템을 '관리하는' 능력을 부여했습니다. 하지만 우리의 LLM은 여전히 수동적입니다. 외부 세계의 정보를 가져와 답변에 활용할 수는 있지만, 스스로 외부 세계에 '영향'을 미치지는 못합니다. 예를 들어, "오늘 샌프란시스코 날씨를 보고, 날씨가 좋으면 내일 아침 9시에 '공원 산책' 일정을 내 캘린더에 추가해줘" 와 같은 복합적인 요청을 한 번에 처리할 수 있을까요?

> LLM이 단순히 정보를 처리하는 것을 넘어, 마치 인간 비서처럼 여러 도구(검색 엔진, 계산기, 캘린더 API)를 활용하여 복잡한 목표를 스스로 계획하고 실행하게 만들려면 무엇이 필요한가?

---

### **2. 에이전트: LLM, 추론 엔진이 되다**

지금까지 우리가 다룬 대부분의 LLM 애플리케이션(단순 Q&A, RAG)은 **'미리 정해진 파이프라인(pre-defined pipeline)'**을 따릅니다.

> `사용자 입력` → `(RAG) 검색` → `프롬프트 구성` → `LLM 호출` → `최종 답변`

이 구조는 예측 가능하고 안정적이지만, 유연성이 떨어집니다. 반면, **에이전트(Agent)**는 이 파이프라인을 동적으로 결정합니다.

*   **에이전트의 정의:** LLM을 핵심 **추론 엔진**으로 사용하여, 주어진 목표를 달성하기 위해 어떤 행동(Action)을 취할지 스스로 결정하고, 그 결과를 관찰(Observation)하여 다음 행동을 계획하는 시스템.

*   **핵심 차이점:** 에이전트는 LLM 호출이 **한 번으로 끝나지 않습니다.** `결정 → 행동 → 관찰`의 순환 고리(loop)를 반복하며 목표에 점진적으로 다가갑니다.

**예시: SQL 데이터베이스 상호작용**

*   **단순 체인(Chain) 방식:**
    1.  자연어 질문을 SQL 쿼리로 변환 (LLM 호출 1)
    2.  SQL 쿼리를 DB에서 실행
    3.  실행 결과를 자연어로 요약 (LLM 호출 2)
    *   **문제점:** 만약 1단계에서 생성된 SQL에 오타가 있다면? 시스템은 그대로 실패합니다.

*   **에이전트(Agent) 방식:**
    1.  **목표:** "가장 많이 팔린 제품 3개는?"
    2.  **생각:** "먼저, 데이터베이스의 테이블 스키마를 확인해야겠다."
    3.  **행동:** `list_tables()` 도구 사용.
    4.  **관찰:** "`products`와 `sales` 테이블이 있구나."
    5.  **생각:** "이제 `sales` 테이블에서 `product_id` 별로 집계하고 정렬하는 쿼리를 짜야지."
    6.  **행동:** `run_sql("SELECT ...")` 도구 사용.
    7.  **관찰:** (만약 에러 발생) "아, `product_id`가 아니라 `item_id`였네. 쿼리를 수정해야겠다."
    8.  ... (성공할 때까지 반복)
    9.  **생각:** "결과를 얻었으니, 이제 사용자에게 자연어로 답변해야지."
    10. **최종 답변:** "가장 많이 팔린 제품은 A, B, C 입니다."

이처럼 에이전트는 **오류로부터 회복**하고, **다단계 추론**을 수행하는 등 훨씬 더 유연하고 강력한 문제 해결 능력을 보여줍니다.

---

### **3. 핵심 프레임워크: ReAct (Reason + Act)**

에이전트를 구현하는 가장 유명하고 효과적인 프롬프팅 전략이 바로 **ReAct**입니다. 2022년 발표된 이 논문은 LLM이 더 나은 행동을 하려면, 먼저 **'생각'**을 해야 한다는 아이디어를 구체화했습니다.

ReAct는 3주차에 배운 **Chain-of-Thought(생각)**와 **행동(도구 사용)**을 결합한 것입니다. LLM은 매 단계마다 다음과 같은 구조의 텍스트를 생성하도록 유도됩니다.

> **Thought:** (현재 상황을 분석하고, 다음 행동을 계획하는 내면의 독백)
> **Action:** (실행할 도구와 그 도구에 전달할 입력값)

이어서 시스템은 해당 Action을 실행하고, 그 결과를 **Observation**으로 다시 LLM에게 전달합니다.

**ReAct 프롬프트 예시 (LangChain 스타일):**

```
You are an agent designed to answer questions.
You have access to the following tools:

Search: A search engine. Useful for when you need to answer questions about current events. Input should be a search query.
Calculator: Useful for when you need to answer questions about math.

Use the following format:

Question: the input question you must answer
Thought: you should always think about what to do
Action: the action to take, should be one of [Search, Calculator]
Action Input: the input to the action
Observation: the result of the action
... (this Thought/Action/Action Input/Observation can repeat N times)
Thought: I now know the final answer
Final Answer: the final answer to the original input question

Begin!

Question: What is the age of the current US president raised to the power of 0.3?
```

**LLM의 생성 과정 (예시):**

> **Thought:** I need to find the current US president's age and then use the calculator. I'll start by searching for the president's age.
> **Action:** Search
> **Action Input:** "current US president age"
>
> *(시스템이 이 Action을 실행하고, 검색 결과를 아래에 붙여줌)*
>
> **Observation:** Joe Biden is 81 years old.
>
> **Thought:** Now I have the age, 81. I need to calculate 81 raised to the power of 0.3.
> **Action:** Calculator
> **Action Input:** 81**0.3
>
> *(시스템이 계산기를 실행하고, 결과를 아래에 붙여줌)*
>
> **Observation:** 3.84
>
> **Thought:** I have calculated the final result.
> **Final Answer:** The current US president's age raised to the power of 0.3 is approximately 3.84.

이처럼 **ReAct**는 LLM이 자신의 행동 계획을 명시적으로 서술하게 함으로써, 더 복잡하고 논리적인 작업을 안정적으로 수행하도록 돕습니다.

---

### **4. LLM에게 도구 쥐여주기 (Tool-Use)**

에이전트의 진정한 힘은 LLM의 한계를 보완해주는 **도구(Tool)**를 사용할 때 발휘됩니다.

*   **도구란?** 에이전트가 호출할 수 있는 모든 함수나 API를 의미합니다.
    *   **정보 획득:** 웹 검색, Wikipedia API, 데이터베이스 쿼리
    *   **계산:** 계산기, Python REPL (코드 실행기)
    *   **외부 세계와 상호작용:** 이메일 보내기, 캘린더 등록, 파일 시스템 조작

#### **4.1. 도구를 어떻게 알려줄까?**

에이전트가 도구를 적재적소에 사용하게 하려면, 프롬프트에 각 도구에 대한 명확한 **'설명서'**를 포함해야 합니다.

*   **도구 이름 (Name):** `Search` 와 같이 에이전트가 호출할 간결한 이름.
*   **도구 설명 (Description):** **"언제 이 도구를 사용해야 하는가?"**에 대한 설명. 이것이 가장 중요합니다. (e.g., "최신 사건이나 시사 상식에 대한 질문에 답해야 할 때 유용함.")
*   **입력 스키마 (Input Schema):** 이 도구가 어떤 입력을 받는지에 대한 설명.

수십, 수백 개의 도구가 있다면 모든 설명을 프롬프트에 넣을 수 없습니다. 이 경우, 사용자 질문과 의미적으로 가장 유사한 도구 설명을 **검색(Tool Retrieval)**하여 동적으로 프롬프트에 포함하는 고급 기법을 사용하기도 합니다.

---

### **5. [실습] 검색 기능이 있는 리서치 에이전트 만들기**

`LangChain`을 사용하여, 웹 검색(Tavily Search API)과 계산기 도구를 사용하는 간단한 에이전트를 만들어 보겠습니다.

#### **5.1. 준비물 및 설정**

```bash
pip install langchain langchain-openai langchain-community tavily-python
```

*   `tavily-python`: Tavily 검색 엔진 API를 사용하기 위한 라이브러리.

[tavily.com](https://tavily.com/)에 가입하여 API 키를 발급받고, 환경 변수로 설정해야 합니다.

```bash
export TAVILY_API_KEY='여러분의_Tavily_API_키'
```

#### **5.2. 에이전트 구현 코드 (`agent_app.py`)**

```python
import os
from langchain_openai import ChatOpenAI
from langchain.agents import tool
from langchain_community.tools.tavily_search import TavilySearchResults
from langchain import hub
from langchain.agents import create_react_agent, AgentExecutor

# --- 1. LLM과 도구 정의 ---
# LLM 초기화
llm = ChatOpenAI(model="gpt-4o", temperature=0)

# LangChain의 @tool 데코레이터를 사용하여 간단한 커스텀 도구를 만듭니다.
@tool
def simple_calculator(expression: str) -> str:
    """Calculates the result of a simple math expression."""
    return str(eval(expression))

# Tavily 검색 도구 초기화
search = TavilySearchResults()

# 사용할 도구들을 리스트로 묶습니다.
tools = [search, simple_calculator]


# --- 2. 에이전트 생성 ---
# LangChain Hub에서 ReAct 프롬프트 템플릿을 가져옵니다.
# 직접 프롬프트를 작성할 수도 있지만, 검증된 템플릿을 사용하는 것이 편리합니다.
prompt = hub.pull("hwchase17/react")

# LLM, 도구, 프롬프트를 결합하여 에이전트를 생성합니다.
agent = create_react_agent(llm, tools, prompt)

# 에이전트 실행기(Executor)를 만듭니다. 
# 이것이 실제로 생각->행동->관찰 루프를 관리합니다.
agent_executor = AgentExecutor(agent=agent, tools=tools, verbose=True)


# --- 3. 에이전트 실행 ---
# 복합적인 질문을 던져봅니다.
question = "How many letters are in the name of the search engine used by this agent?"
response = agent_executor.invoke({"input": question})

print("\n--- Final Response ---")
print(response['output'])
```
**실행 결과 (`verbose=True` 덕분에 내부 루프가 출력됨):**

```
> Entering new AgentExecutor chain...
Thought: The user is asking about the name of the search engine I'm using. I should check the tools I have to see if I can find that information. The tool definitions might contain the name. The search tool is `TavilySearchResults`. The name of the search engine is Tavily. Now I need to count the letters in "Tavily".
T-a-v-i-l-y. That's 6 letters.
Final Answer: 6

> Finished chain.

--- Final Response ---
6
```
이 예시는 에이전트가 외부 도구(Tavily)를 호출하지 않고, 자기 자신에게 주어진 **프롬프트(도구 설명)를 성찰**하여 답을 찾는 놀라운 능력을 보여줍니다. 이는 에이전트가 얼마나 유연하게 문제를 해결하는지 보여주는 좋은 사례입니다.

---

### **6. 8주차 정리 및 과제**

#### **핵심 요약 (Key Takeaways)**

*   **에이전트**는 LLM을 **추론 엔진**으로 사용하여, 정해진 파이프라인 없이 동적으로 행동을 계획하고 실행하는 시스템입니다.
*   **ReAct (Reason + Act)**는 '생각'과 '행동'을 명시적으로 분리하여, 에이전트가 더 안정적으로 복잡한 작업을 수행하도록 돕는 핵심 프레임워크입니다.
*   **도구(Tool-Use)**는 LLM의 한계(계산, 최신 정보, 외부 시스템 연동)를 극복하고 에이전트의 능력을 무한히 확장시켜 줍니다.
*   에이전트는 아직 **신뢰성, 제어, 평가** 측면에서 많은 도전 과제를 안고 있으며, 이는 활발한 연구 개발이 진행 중인 분야입니다.

#### **다음 주 예고 (Next Week's Preview)**

지금까지 우리는 주로 OpenAI와 같은 외부 API를 활용해 왔습니다. 하지만 특정 도메인에 고도로 특화되거나, 비용 효율적이거나, 데이터 프라이버시가 중요한 경우에는 어떻게 해야 할까요? 다음 주에는 기성 모델을 넘어, **직접 LLM을 훈련하는 방법**에 대해 Replit의 사례를 통해 알아보겠습니다.

#### **과제 (Assignment)**

1.  **[에이전트 한계 탐색]**
    *   오늘 만든 `agent_app.py`를 실행하며, 에이전트가 실패하거나 비효율적으로 작동하는 질문을 만들어 보세요.
    *   예시: "내 컴퓨터에 있는 'report.docx' 파일을 요약해줘." (에이전트는 로컬 파일 시스템에 접근할 도구가 없으므로 실패할 것입니다.)
    *   예시: 매우 모호하거나 중의적인 질문.
    *   에이전트가 실패한 이유를 분석하고, 만약 여러분이 이 에이전트를 개선한다면 어떤 '도구'를 추가해주고 싶은지 구체적으로 설명해 보세요.

2.  **[커스텀 도구 만들기]**
    *   `@tool` 데코레이터를 사용하여, 오늘의 날짜와 시간을 반환하는 `get_current_time`이라는 새로운 도구를 만들어 보세요. (`datetime` 라이브러리 사용)
    *   이 도구를 `tools` 리스트에 추가하고, 에이전트에게 "지금 몇 시야?"와 같은 질문을 던져 새로운 도구를 잘 사용하는지 확인해 보세요.
    *   성공적으로 작동하는 전체 코드와 실행 결과를 강의 토론 포럼에 공유해 주세요.